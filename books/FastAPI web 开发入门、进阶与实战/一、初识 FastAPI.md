# FastAPI 框架概述

## 1. FastAPI 与其他框架

- Bottle 是一个比较小众的框架，是众多Web框架中最简单、快速和轻量级的WSGI微型Web框架，整个框架只有一个文件模块。框架本身除了Python标准库之外，不产生其他第三方的依赖项
- Flask 也是一个轻量级的 Web 应用框架，是基 于Werkzeug WSGI 工具箱和 Jinja2 模板引擎而开发出来的。Flask 自己也宣称是一个 Micro Framework 的框架。Flask 之所以比 Bottle 更加受欢迎，是因为它自身的设计非常好，对于一些功能插件也保留了弹性扩展，而且它是持续更新维护的

- Django 是一个大而全的框架，是一个完整的 Web 开发框架。对于小业务场景来说，使用Django框架会过于笨重，部分模块也无法进行定制

- Sanic 和 FastAPI 框架一样，是一个异步框架。它是首批基于 asyncio 的极端快速 Python 框架之一。它允许使用 Python 3.5 中添加的 async/await 语法，这使得用户的代码不阻塞，速度更快。它不仅是一个框架，也是一个服务器，可以随时为用户编写的 Web 应用程序提供部署服务



## 2. FastAPI 的特性

FastAPI为了构建快速的API而生，其主要特性有：

1. 是一个支持 ASGI 协议的 web 应用框架，也就是说，它同时兼容 ASGI 和 WSGI 的应用
2. 天然支持异步协程处理，能快速处理更多的 HTTP 请求
3. 使用了 Pydantic 类型提示的特性，可以更加高效、快速的进行接口数据类型校验及模型响应等处理
4. 基于 Pydantic 莫信号，可以自动对响应数据进行格式化和序列化处理
5. 提供依赖注入系统的实现，可以让用户更高效的进行代码复用
6. 支持 websocket、graphQL
7. 支持异步后台任务，可以方便的对耗时的任务进行异步处理
8. 支持服务进程启动和关闭实践回调监听，可以方便的进行一些插件的扩展初始化
9. 支持跨域请求 CORS、压缩 GZip 请求、静态文件、流式响应
10. 支持自定义相关中间件来处理请求及响应
11. 支持开箱即用 OpenAPI（即 swagger）和 JSON Schema，可以自动生成交互式文档
12. 使用 uvloop 模块，让原生标准的 asyncio 内置的事件循环更快



## 3. 异步编程基础

FastAPI 的最大特性就是异步支持

ASGI 是一种接口协议，它是为了规范支持异步的 Python Web 服务器、框架和应用之间的通信而定制的，同时囊括了同步和异步应用的通信规范，并且向后兼容 WSGI 协议



### 3.1 并发编程机制

通常，计算机的任务主要分为两种

- 一种是计算型密集任务
- 另一种则是 IO 密集型任务（如输入/输出阻塞、磁盘IO、网络请求IO）



程序处理并发问题的常见方案是多线程和多进程，那么为什么需要使用多线程和多进程方式来实现并发呢，这就需要回到同步 IO 编程模式的问题上：

在同步 IO 编程中，由于 CPU 处理任务计算的速度远高于内存执行任务的速度，所以会遇到 IO 阻塞引发的执行效率低的问题

引入多线程和多进程方式在某种程度上可以实现多任务并发执行。线程相互之间独立执行，互不影响。对于IO型任务，通常通过多线程调度来实现表面上的并发；对于计算密集型任务，则使用多进程来实现并发。

虽然引入多线程和多进程方式在某种程度上可以实现多任务并发执行，但是也相应低存在一定的缺点，在 python 中主要体现为：

- python 多进程的缺点：
  - 进程的创建和销毁代价非常高
  - 需要开辟更多的虚拟空间
  - 多进程之间上下文的切换时间长
  - 需要考虑多进程之间的同步问题
- python 多线程并发缺点：
  - 每一个线程都包含一个内核调用栈和 CPU 寄存器上下文表
  - 共享同一个进程空间会涉及同步问题
  - 线程之间上下文的切换需要消耗时间
  - 受限于 GIL，在 python 进程中只允许一个线程处于运行状态，多线程无法充分利用 CPU 多核
  - 受 OS 调度管制，线程是抢占式多任务并发的（需要关心同步问题）

相对同步 IO 而生的异步 IO，要解决的问题是在处理任务时，若遇到 IO 阻塞，则会变为非 IO 阻塞，也就是说遇到 IO 任务时，CPU 不会等待 IO 任务执行完成，而是直接继续后续任务的执行。从某种程度上，提高了CPU 的使用率。

异步 IO 的本质是基于事件触发机制来实现异步回调。在 IO 处理上主要采用了 IO 复用机制来实现非阻塞操作



### 3.2 并发与并行

1. 并发：

   并发通常是指在单核 CPU 情况下可以同时运行多个应用程序

   实际上，操作系统（单核 CPU 的情况）在处理任务时任一时刻点都只有一个程序在 CPU 中运行

   操作系统给每个应用程序（任务）都分配了一定的时间片，每个程序执行完分配的时间片后，操作系统会通过调度切换到下一个任务中去执行

2. 并行：

   如果计算机使用的是多核 CPU，那么任务就可以分配到不同的 CPU 上执行，在这种情况下，在多个 CPU 上执行的任务互不干扰、互不影响，这是真正的多任务同时执行，也是一种真正的并行表现

综上：

- 并行包含了并发，并发是并行的一种特殊表现
- 并发通常是对单核 CPU 任务执行过程的一种组织结构描述的说明；并行是对程序执行过程中一种状态的描述，其主要目的是充分利用多核 CPU 加速任务执行



### 3.3 同步与异步

通常所说的同步(Synchronous)，其实是在强调多个任务执行的一个完整过程，其中的某个任务在执行过程中不允许被中断。多个任务的执行必须是协调一致且有序的，某个任务在执行过程中如遇到阻塞，则其他任务需要等待。

相对于同步来说，异步(Asynchronous)强调多个任务可以分开执行，彼此之间互不影响，某一个任务遇到阻塞，其他任务不需要等待，但是任务执行的结果依然是保持一致的

综上：

- 同步和异步是一种线程处理方式，它们的主要区别是遇到 IO 请求是否等待
- 同步：代码调用 IO 操作时，必须等待 IO 操作完成才返回
- 异步：代码调用 IO 操作时，不必等待 IO 操作完成就可以返回

- 异步操作是可以被阻塞的，只不过它不是在处理消息时被阻塞，而是在等待消息通知时被阻塞



### 3.4 阻塞与非阻塞

阻塞和非阻塞都是针对 CPU 对线程的调度来说的

1. 阻塞：

   当调用的函数（任务）遇到 IO 时会进行线程挂起的操作，此时就需要等待返回 IO 执行结果，在等待的过程中无法处理其他任务，此时的任务执行操作就处于阻塞状态

2. 非阻塞：

   当调用的函数遇到 IO 时，若不会进行线程挂起的操作，则不需要等待返回 IO 执行结果，此时可以去做其他子任务，此时的任务执行操作即处于非阻塞状态

综上：

- 阻塞和非阻塞描述的是程序的运行状态，表示的是程序在等待消息时的状态
- 阻塞和非阻塞是线程的状态，线程要么处于阻塞状态，要么处于非阻塞状态，两者并不冲突，它们的主要区别是在数据没准备好的情况下调用函数时当前线程是否立即返回



## 4. asyncio 协程概念

不论是多线程还是多进程，在 Python 中所用的并发模式都是“假象”

1. 早期 web 框架大都基于多线程模式来进行并发支持，需要消耗的资源比较多
2. 而系统资源是有限的，所以考虑在单一进程中或线程中同时处理更多的请求，所以一些 IO 多路复用模型应运而生
3. 但是 IO 多路复用模型依赖于回调”，这种回调机制使用起来复杂，而且容易出现链路式回调，编码实现也不够直观
4. 后来链路式回调机制就慢慢被新的协程机制替代

相对于线程来说，协程式不存在于 OS 中的，协程是工作在程序级别上的 IO 调度，可以理解为对现有线程进行的一次分片任务处理，线程可以在代码块之间来回切换执行，而非逐行执行，因此能够支持更快的上下文切换，减少线程的创建开销和切换开销，从而大大提高了系统性能



基于 asyncio，可以在单线程模式下处理更多的并发任务，它是一个异步 IO 框架，而异步 IO 其实是基于事件触发机制来实现异步回调的，在 IO 处理上主要采用了 IO 复用机制来实现非阻塞操作

asyncio 的核心是 Eventloop（事件循环），它以 Eventloop 为核心来实现协程函数结果的回调。它提供了相关协程任务的注册、取消、执行及回调等方法来实现并发。